<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ts1989</title>
  <icon>http://example.com/icon.png</icon>
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-01T06:57:58.231Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jinming Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>struct和clas的本质区别</title>
    <link href="http://example.com/2024/01/02/struct%E5%92%8Cclas%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2024/01/02/struct%E5%92%8Cclas%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</id>
    <published>2024-01-02T13:21:24.000Z</published>
    <updated>2024-04-01T06:57:58.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h2><p>struct是值类型，而class是引用类型。值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。虽然堆栈的执行效率要比堆的高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，用class来处理更复杂的商业逻辑。</p><h2 id="其他的使用上的区别"><a href="#其他的使用上的区别" class="headerlink" title="其他的使用上的区别"></a>其他的使用上的区别</h2><ol><li>struct字段和继承方式默认public，class则是private</li><li>结构体存储自身的数据，class仅存储一个动态对象的引用</li><li>C语言中struct不可以为空，但是C++中可以</li></ol>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;h2 id=&quot;本质区别&quot;&gt;&lt;a href=&quot;#本质区别&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>shared_ptr的简易实现</title>
    <link href="http://example.com/2023/08/11/shared-ptr%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/08/11/shared-ptr%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-08-11T04:56:32.000Z</published>
    <updated>2024-04-01T05:49:32.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现一个简易shared-ptr模板类需要些什么"><a href="#实现一个简易shared-ptr模板类需要些什么" class="headerlink" title="实现一个简易shared_ptr模板类需要些什么"></a>实现一个简易shared_ptr模板类需要些什么</h2><ol><li>引用计数</li><li>控制对引用计数访问权限的互斥锁</li><li>构造函数，拷贝构造函数，重载赋值运算符，解引用运算符等等</li><li>析构函数，避免在临界区访问引用计数</li></ol><h2 id="类的私有成员变量"><a href="#类的私有成员变量" class="headerlink" title="类的私有成员变量"></a>类的私有成员变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_shared_ptr</span>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span>* _p_ref_count;<br>  std::mutex* _p_mutex;<br>  T* _p_ptr;<br>&#125;; <br></code></pre></td></tr></table></figure><h2 id="定义构造与析构函数"><a href="#定义构造与析构函数" class="headerlink" title="定义构造与析构函数"></a>定义构造与析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_shared_ptr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">my_shared_ptr</span>(T* ptr=<span class="hljs-literal">nullptr</span>): <br>    _p_ref_count(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)),<br>    _p_mutex(<span class="hljs-keyword">new</span> std::mutex),<br>    _p_ptr(ptr) &#123;&#125;<br>  <span class="hljs-built_in">my_shared_ptr</span>(<span class="hljs-type">const</span> my_shared_ptr&lt;T&gt;&amp; msp)<br>    _p_ref_count(msp._p_ref_count),<br>    _p_mutex(msp._p_mutex),<br>    _p_ptr(msp._p_ptr) &#123;<br>      <span class="hljs-built_in">add_ref_count</span>();<br>    &#125;<br>  ~<span class="hljs-built_in">my_shared_ptr</span>() &#123;<br>    <span class="hljs-built_in">release</span>();<br>  &#125;<br>  my_shared_ptr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> my_shared_ptr&lt;T&gt;&amp; msp) &#123;<br>    <span class="hljs-keyword">if</span>(_p_ptr!=msp._p_ptr) &#123;<br>      <span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放旧资源</span><br>      _p_ref_count = msp._p_ref_count;<br>      _p_mutex = msp._p_mutex;<br>      _p_ptr = msp._p_ptr;<br>      <span class="hljs-built_in">add_ref_count</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>    <span class="hljs-keyword">return</span> *_p_ptr;<br>  &#125;<br>  T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>    <span class="hljs-keyword">return</span> _p_ptr;<br>  &#125;<br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _p_ptr;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_ref_count</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *_p_ref_count;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_ref_count</span><span class="hljs-params">()</span> </span>&#123;<br>    _p_mutex-&gt;<span class="hljs-built_in">lock</span>();<br>    ++(*_p_ref_count);<br>    _p_mutex-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">bool</span> delete_flag = <span class="hljs-literal">false</span>;<br>    _p_mutex-&gt;<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(--(*_p_ref_count)==<span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> _p_ref_count;<br>      <span class="hljs-keyword">delete</span> _p_ptr;<br>      delete_flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    _p_mutex-&gt;<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">if</span>(delete_flag) <span class="hljs-keyword">delete</span> _p_mutex;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><ol><li>my_shared_ptr对象中的引用计数因为使用了互斥锁所以是线程安全的</li><li>但是my_shared_ptr管理的对象存放在堆上，如果两个线程同时访问，则将造成线程安全问题</li></ol><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>my_shared_ptr模板类没有考虑不是new出来的对象，实际上shared_ptr针对这种情况设计了仿函数删除器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 仿函数的删除器</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FreeFunc</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;free:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteArrayFunc</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;delete[]&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] ptr;<br>  &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>  FreeFunc&lt;<span class="hljs-type">int</span>&gt; freeFunc;<br>  <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">((<span class="hljs-type">int</span>*)malloc(<span class="hljs-number">4</span>), freeFunc)</span></span>;<br>  DeleteArrayFunc&lt;<span class="hljs-type">int</span>&gt; deleteArrayFunc;<br>  <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">((<span class="hljs-type">int</span>*)malloc(<span class="hljs-number">4</span>), deleteArrayFunc)</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">自己动手实现my_shared_ptr模板类</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>tcp粘包问题的成因与解决方案</title>
    <link href="http://example.com/2023/07/08/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%88%90%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2023/07/08/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%88%90%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2023-07-08T01:56:40.000Z</published>
    <updated>2024-04-01T06:16:44.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP粘包问题是什么"><a href="#TCP粘包问题是什么" class="headerlink" title="TCP粘包问题是什么"></a>TCP粘包问题是什么</h2><p>TCP粘包问题指的是发送方发送的若干数据包在到达接收方时粘成了一包</p><h2 id="造成粘包问题的可能原因"><a href="#造成粘包问题的可能原因" class="headerlink" title="造成粘包问题的可能原因"></a>造成粘包问题的可能原因</h2><h3 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h3><p>TCP接收端接收到数据包时，并不会直接交给应用程序处理，而是会先放到缓存中，如果应用程序从缓存中读取数据包的速度<br>小于TCP将接收到的数据包放到缓存中的速度，多个数据包在缓存中就有可能首尾相连</p><h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><p>使用了Nagle算法，在收到一次确认时，才会发送下一个分组，并且这个分组是多个小分组的集合体</p><h2 id="一定要解决粘包问题吗"><a href="#一定要解决粘包问题吗" class="headerlink" title="一定要解决粘包问题吗"></a>一定要解决粘包问题吗</h2><p>不一定，如果这些数据包本来就是同一块数据的不同部分，那么没必要处理；如果是多个并列的，或者是多个互不相关的分组<br>，那就必须要处理了</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><ol><li>发送方： 可以使用TCP_NODELAY选项关闭NAGLE算法</li><li>应用层：格式化数据，使得每条数据有固定的格式（开始符，结束符），并在发送时一并发送数据长度，这样接收方应用程序就能轻松读取数据包长度，方便循环处理</li></ol><h2 id="UDP会出现粘包问题吗"><a href="#UDP会出现粘包问题吗" class="headerlink" title="UDP会出现粘包问题吗"></a>UDP会出现粘包问题吗</h2><p>不会，UDP协议面向数据报，TCP协议面向流，UDP保护消息边界，TCP不保护，所以TCP会出现粘包问题，UDP不会  </p>]]></content>
    
    
    <summary type="html">本文探讨了因Nagle算法导致的tcp粘包问题</summary>
    
    
    
    
    <category term="network" scheme="http://example.com/tags/network/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++中的菱形继承问题</title>
    <link href="/2024/04/08/C-%E4%B8%AD%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/"/>
    <url>/2024/04/08/C-%E4%B8%AD%E7%9A%84%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是菱形继承"><a href="#什么是菱形继承" class="headerlink" title="什么是菱形继承"></a>什么是菱形继承</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandfather</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">grandfather</span>() &#123;<br>    age = <span class="hljs-number">108</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>: <span class="hljs-keyword">public</span> grandfather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>: <span class="hljs-keyword">public</span> grandfather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> :<span class="hljs-keyword">public</span> father1, <span class="hljs-keyword">public</span> father2&#123;&#125;;<br></code></pre></td></tr></table></figure><p>这时son就是菱形继承的产物，如果编写以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  son s;<br>  s.age=<span class="hljs-number">4</span>;<br>  cout&lt;&lt;s.age;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至无法通过编译</p><p><img src="/image.png" alt="alt text"></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><ol><li>手动写明作用域</li><li>使用virtual public 继承</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    son s;<br>    s.father1::age = <span class="hljs-number">4</span>;<br>    cout &lt;&lt; s.father1::age;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>```cpp<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandfather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> grandfather&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> :<span class="hljs-keyword">public</span> father1, <span class="hljs-keyword">public</span> father2&#123;&#125;;<br></code></pre></td></tr></table></figure><p>以上两种方式均可以通过编译，但是使用第二种方式的话，p.age, p.father1::age, p.father2::age其实会指向同一块内存区域，既浪费了空间(多了两个vbptr),又没起到任何作用，所以还是要尽量避免菱形继承的使用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中的仿函数</title>
    <link href="/2024/04/08/C-%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    <url>/2024/04/08/C-%E4%B8%AD%E7%9A%84%E4%BB%BF%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="仿函数是什么"><a href="#仿函数是什么" class="headerlink" title="仿函数是什么"></a>仿函数是什么</h2><p>仿函数(Functor)在C++中和函数对象是一个概念，它们都是重载了函数调用运算符的类的对象，Functor是STL六大模块之一，其余模块分别是Container, Algorithm, Iterator, Adaptor, Allocator.</p><h2 id="仿函数存在的意义"><a href="#仿函数存在的意义" class="headerlink" title="仿函数存在的意义"></a>仿函数存在的意义</h2><p>仿函数的作用和C语言中的函数指针很像，但它扩展性更好。当我们需要为某种算法提供特定“操作”（比如说排序方式）时，我们可以传入函数指针，但如果将来这个函数的签名（参数个数，参数类型，参数顺序，不包括返回值类型）发生了变化，就需要做很大调整了。其次，函数之间可能会共用变量，维护全局变量也很麻烦。仿函数就没有这些缺点，它可以被依赖、组合和继承，在自己的类中维护变量，功能更加强大。</p><p>比如在用到unordered_map或者unordered_set的时候，我们可能会需要将自定义类用作key，这时我们需要做两件事</p><ol><li>为这个类重载等于运算符</li><li>提供用于hash的仿函数</li></ol><p>举个例子，对于下面这个磁盘页面类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PageId</span> &#123;<br>  <span class="hljs-type">int</span> fd;<br>  <span class="hljs-type">page_id_t</span> page_no = INVALID_PAGE_ID;<br>  <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> PageId&amp; x, <span class="hljs-type">const</span> PageId&amp; y) &#123;<br>    <span class="hljs-keyword">return</span> x.fd==y.fd&amp;&amp;x.page_no==y.page_no;<br>  &#125;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> PageId &amp;x) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (fd &lt; x.fd)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> page_no &lt; x.page_no;<br>  &#125;<br>  <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;fd: &quot;</span> + std::<span class="hljs-built_in">to_string</span>(fd) +<br>           <span class="hljs-string">&quot; page_no: &quot;</span> + std::<span class="hljs-built_in">to_string</span>(page_no) + <span class="hljs-string">&quot;&#125;&quot;</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int64_t</span> <span class="hljs-title">Get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int64_t</span>&gt;(fd &lt;&lt; <span class="hljs-number">16</span>) | page_no);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们需要提供一个hash函数对象，从而构建一个unordered_map,使得磁盘中的页和内存中的帧可以一一对应</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PageIdHash</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> PageId &amp;x)</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> (x.fd &lt;&lt; <span class="hljs-number">16</span>) | x.page_no; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们就可以获得std::unordered_map&lt;PageId,frame_id_t,PageIdHash&gt;了，如果我们想要提供默认实现，可以<br>再使用模板特化的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">std</span>::hash&lt;PageId&gt; &#123;<br>  <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> PageId &amp;obj)</span> <span class="hljs-type">const</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">hash</span>&lt;<span class="hljs-type">int64_t</span>&gt;()(obj.<span class="hljs-built_in">Get</span>());<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有时候仿函数的存在是为了让函数具有类的性质，通过仿函数，我们可以在拥有函数功能的同时，拥有状态，依据函数生成对象，让函数能彼此继承。仿函数主要在STl中使用，lambda的内部实现也是用的仿函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>struct和clas的本质区别</title>
    <link href="/2024/01/02/struct%E5%92%8Cclas%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/01/02/struct%E5%92%8Cclas%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="本质区别"><a href="#本质区别" class="headerlink" title="本质区别"></a>本质区别</h2><p>struct是值类型，而class是引用类型。值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。虽然堆栈的执行效率要比堆的高，但是堆栈资源却很有限，不适合处理逻辑复杂的大对象，因此struct常用来处理作为基类型对待的小对象，用class来处理更复杂的商业逻辑。</p><h2 id="其他的使用上的区别"><a href="#其他的使用上的区别" class="headerlink" title="其他的使用上的区别"></a>其他的使用上的区别</h2><ol><li>struct字段和继承方式默认public，class则是private</li><li>结构体存储自身的数据，class仅存储一个动态对象的引用</li><li>C语言中struct不可以为空，但是C++中可以</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shared_ptr的简易实现</title>
    <link href="/2023/08/11/shared-ptr%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/08/11/shared-ptr%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="实现一个简易shared-ptr模板类需要些什么"><a href="#实现一个简易shared-ptr模板类需要些什么" class="headerlink" title="实现一个简易shared_ptr模板类需要些什么"></a>实现一个简易shared_ptr模板类需要些什么</h2><ol><li>引用计数</li><li>控制对引用计数访问权限的互斥锁</li><li>构造函数，拷贝构造函数，重载赋值运算符，解引用运算符等等</li><li>析构函数，避免在临界区访问引用计数</li></ol><h2 id="类的私有成员变量"><a href="#类的私有成员变量" class="headerlink" title="类的私有成员变量"></a>类的私有成员变量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_shared_ptr</span>&#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span>* _p_ref_count;<br>  std::mutex* _p_mutex;<br>  T* _p_ptr;<br>&#125;; <br></code></pre></td></tr></table></figure><h2 id="定义构造与析构函数"><a href="#定义构造与析构函数" class="headerlink" title="定义构造与析构函数"></a>定义构造与析构函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_shared_ptr</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">my_shared_ptr</span>(T* ptr=<span class="hljs-literal">nullptr</span>): <br>    _p_ref_count(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>)),<br>    _p_mutex(<span class="hljs-keyword">new</span> std::mutex),<br>    _p_ptr(ptr) &#123;&#125;<br>  <span class="hljs-built_in">my_shared_ptr</span>(<span class="hljs-type">const</span> my_shared_ptr&lt;T&gt;&amp; msp)<br>    _p_ref_count(msp._p_ref_count),<br>    _p_mutex(msp._p_mutex),<br>    _p_ptr(msp._p_ptr) &#123;<br>      <span class="hljs-built_in">add_ref_count</span>();<br>    &#125;<br>  ~<span class="hljs-built_in">my_shared_ptr</span>() &#123;<br>    <span class="hljs-built_in">release</span>();<br>  &#125;<br>  my_shared_ptr&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> my_shared_ptr&lt;T&gt;&amp; msp) &#123;<br>    <span class="hljs-keyword">if</span>(_p_ptr!=msp._p_ptr) &#123;<br>      <span class="hljs-built_in">release</span>(); <span class="hljs-comment">// 释放旧资源</span><br>      _p_ref_count = msp._p_ref_count;<br>      _p_mutex = msp._p_mutex;<br>      _p_ptr = msp._p_ptr;<br>      <span class="hljs-built_in">add_ref_count</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  T&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>    <span class="hljs-keyword">return</span> *_p_ptr;<br>  &#125;<br>  T* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>    <span class="hljs-keyword">return</span> _p_ptr;<br>  &#125;<br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> _p_ptr;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_ref_count</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> *_p_ref_count;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_ref_count</span><span class="hljs-params">()</span> </span>&#123;<br>    _p_mutex-&gt;<span class="hljs-built_in">lock</span>();<br>    ++(*_p_ref_count);<br>    _p_mutex-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">bool</span> delete_flag = <span class="hljs-literal">false</span>;<br>    _p_mutex-&gt;<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(--(*_p_ref_count)==<span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">delete</span> _p_ref_count;<br>      <span class="hljs-keyword">delete</span> _p_ptr;<br>      delete_flag = <span class="hljs-literal">true</span>;<br>    &#125;<br>    _p_mutex-&gt;<span class="hljs-built_in">unlock</span>();<br>    <span class="hljs-keyword">if</span>(delete_flag) <span class="hljs-keyword">delete</span> _p_mutex;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><ol><li>my_shared_ptr对象中的引用计数因为使用了互斥锁所以是线程安全的</li><li>但是my_shared_ptr管理的对象存放在堆上，如果两个线程同时访问，则将造成线程安全问题</li></ol><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>my_shared_ptr模板类没有考虑不是new出来的对象，实际上shared_ptr针对这种情况设计了仿函数删除器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 仿函数的删除器</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FreeFunc</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;free:&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-built_in">free</span>(ptr);<br>  &#125;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DeleteArrayFunc</span> &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;delete[]&quot;</span> &lt;&lt; ptr &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] ptr;<br>  &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <br>  FreeFunc&lt;<span class="hljs-type">int</span>&gt; freeFunc;<br>  <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp1</span><span class="hljs-params">((<span class="hljs-type">int</span>*)malloc(<span class="hljs-number">4</span>), freeFunc)</span></span>;<br>  DeleteArrayFunc&lt;<span class="hljs-type">int</span>&gt; deleteArrayFunc;<br>  <span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sp2</span><span class="hljs-params">((<span class="hljs-type">int</span>*)malloc(<span class="hljs-number">4</span>), deleteArrayFunc)</span></span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcp粘包问题的成因与解决方案</title>
    <link href="/2023/07/08/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%88%90%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/07/08/tcp%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%88%90%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP粘包问题是什么"><a href="#TCP粘包问题是什么" class="headerlink" title="TCP粘包问题是什么"></a>TCP粘包问题是什么</h2><p>TCP粘包问题指的是发送方发送的若干数据包在到达接收方时粘成了一包</p><h2 id="造成粘包问题的可能原因"><a href="#造成粘包问题的可能原因" class="headerlink" title="造成粘包问题的可能原因"></a>造成粘包问题的可能原因</h2><h3 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h3><p>TCP接收端接收到数据包时，并不会直接交给应用程序处理，而是会先放到缓存中，如果应用程序从缓存中读取数据包的速度<br>小于TCP将接收到的数据包放到缓存中的速度，多个数据包在缓存中就有可能首尾相连</p><h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><p>使用了Nagle算法，在收到一次确认时，才会发送下一个分组，并且这个分组是多个小分组的集合体</p><h2 id="一定要解决粘包问题吗"><a href="#一定要解决粘包问题吗" class="headerlink" title="一定要解决粘包问题吗"></a>一定要解决粘包问题吗</h2><p>不一定，如果这些数据包本来就是同一块数据的不同部分，那么没必要处理；如果是多个并列的，或者是多个互不相关的分组<br>，那就必须要处理了</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><ol><li>发送方： 可以使用TCP_NODELAY选项关闭NAGLE算法</li><li>应用层：格式化数据，使得每条数据有固定的格式（开始符，结束符），并在发送时一并发送数据长度，这样接收方应用程序就能轻松读取数据包长度，方便循环处理</li></ol><h2 id="UDP会出现粘包问题吗"><a href="#UDP会出现粘包问题吗" class="headerlink" title="UDP会出现粘包问题吗"></a>UDP会出现粘包问题吗</h2><p>不会，UDP协议面向数据报，TCP协议面向流，UDP保护消息边界，TCP不保护，所以TCP会出现粘包问题，UDP不会  </p>]]></content>
    
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
